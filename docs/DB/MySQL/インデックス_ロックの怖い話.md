どの順番で効くか不明。　　
レコードを登録して試してみも、今一つ。  
```sql
  KEY `items_index_1` (`parent_job_id`,`deleted_at`),
  KEY `items_index_2` (`parent_job_id`,`child_job_sequence_no`,`deleted_at`),
  KEY `items_index_3` (`extends_relation_key`)
```

インデックスが設定されていても、ある程度の量のレコードが無いと、インデックスが効かない？  

parent_job_id と deleted_at のみを where 句に含めると、items_index_1 が効きそうだけど、そうでもないみたい。  
そのため、どのインデックスが有効となるか、判定が難しい。  

また、インデックスを一度効かせると、その内容を保持し、以降はその情報を参照する（と思われる）。  
そのため、現象の再現は難しい。  

## 複数カラムを使用したインデックス
順番が重要みたい。  

Good : parent_job_id, deleted_at
Bad  : deleted_at   , parent_job_id

## UPDATE時のインデックス
update 文を発行する時もインデックスを使用する。  

→ id による select 句の絞り込みをして、その値にて update 文を発行。  

__________________________________________________________________________________________
# 暫定対応
デッドロックのタイムアウト時間を伸ばす。  
（デッドロックは、一定時間経過後（一定時間ウェイトした後）に発生する）  

## ロックのタイムアウト時間
```
-- SET innodb_lock_wait_timeout=300
-- SET innodb_lock_wait_timeout=50
 SHOW VARIABLES LIKE 'innodb_lock_wait_timeout'
```

## RDS：パラメータグループ
innodb_lock_wait_timeout  
lock_wait_timeout  


__________________________________________________________________________________________

## InnoDB のロック機構について
https://medium.com/@terako.studio/innodb-%E3%81%AE%E3%83%AD%E3%83%83%E3%82%AF%E6%A9%9F%E6%A7%8B%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6-626a1c423185

